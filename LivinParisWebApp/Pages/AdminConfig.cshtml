@page
@model LivinParisWebApp.Pages.AdminConfigModel
@{
    Layout = "~/Pages/Shared/_LayoutVoidNavBar.cshtml";
    ViewData["Title"] = "Panel Admin";
}
<head>
    <link rel="stylesheet" href="/css/site.css" />
</head>
<div>
    <form method="post">
        <button type="submit" asp-page-handler="LoadStationInBDD">
            Charger la BDD avec les stations
        </button>
        <button type="submit" asp-page-handler="DeleteContenuStations">Vider la table Station</button>
        <button type="submit" asp-page-handler="GenererGraphe">Générer le graphe</button>
    </form>
</div>
<div class="img-container"> 
     <p>Visualisation du graphe complet du projet</p>
     <div id="map" style="height: 600px; width: 100%; border-radius: 10px;"></div>
</div>
@section Scripts {
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

    <script>
        const ligneColors = {
            1: "#FFCD00",  // jaune
            2: "#003CA6",  // bleu
            3: "#837902",  // kaki
            "3bis": "#6EC4E8", // bleu clair
            4: "#CF009E",  // rose/magenta
            5: "#FF7E2E",  // orange
            6: "#6ECEB2",  // vert d’eau
            7: "#F5A9BB",  // rose clair
            "7bis": "#6ECA97", // vert pastel
            8: "#E19BDF",  // violet clair
            9: "#B6BD00",  // jaune/vert
            10: "#C9910D", // ocre
            11: "#704B1C", // brun
            12: "#007852", // vert foncé
            13: "#99D4E4", // bleu glacier
            14: "#62259D", // violet foncé
        }

        const stations = @Html.Raw(ViewData["Stations"]);

        const arcs = @Html.Raw(ViewData["Arcs"]);

        const map = L.map('map').setView([48.8566, 2.3522], 12);

        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        stations.forEach(station => {
            const marker = L.circleMarker([station.latitude, station.longitude], {
                radius: 5,
                fillColor: "#ff5e5e",
                color: "#000",
                weight: 1,
                opacity: 0.3,
                fillOpacity: 0.3
            }).addTo(map);
            marker.bindPopup(`<strong>${station.nom}</strong><br/>ID: ${station.id}`);
        });

        arcs.forEach(arc => {
            const src = arc.source;
            const dest = arc.destination;
            const ligne = arc.ligne;

            const color = ligneColors[ligne] || "#000";

            L.polyline([
                [src.latitude, src.longitude],
                [dest.latitude, dest.longitude]
            ], {
                color: color,
                weight: 4,
                opacity: 0.5
            }).addTo(map);
        });
        
        stations.forEach(station => {
            const correspondances = stations.filter(s => s.nom === station.nom && s.id !== station.id);

            correspondances.forEach(corresp => {
                arcs.push({
                    source: station,
                    destination: corresp,
                    ligne: "correspondance",
                    distance: 0.1,
                });
            });
        });

        function ajouterCorrespondancesFixes(stations, arcs) {
            const correspondances = [
                [44, 45], [65, 66], [69, 70],
                [95, 96], [113, 114], [141, 142], [171, 172],
                [180, 181], [209, 210], [240, 241], [261, 262],
                [273, 274], [299, 300], [319, 320]
            ];

            correspondances.forEach(([id1, id2]) => {
                const station1 = stations.find(s => s.id === id1);
                const station2 = stations.find(s => s.id === id2);

                if (station1 && station2) {
                    arcs.push({
                        source: station1,
                        destination: station2,
                        ligne: "correspondance",
                        distance: 0
                    });
                    arcs.push({
                        source: station2,
                        destination: station1,
                        ligne: "correspondance",
                        distance: 0
                    });
                } else {
                    console.warn(`Stations non trouvées pour la correspondance : ${id1}, ${id2}`);
                }
            });

            console.log("✅ Correspondances fixes ajoutées !");
        }

        
        ajouterCorrespondancesFixes(stations, arcs);


       

    </script>

    <script>

        const graph = {};

        stations.forEach(st => {
            graph[st.id] = [];
        });

        arcs.forEach(arc => {
            graph[arc.source.id].push({
                id: arc.destination.id,
                distance: arc.distance
            });
        });

        
        function dijkstra(graph, startId) {
            const distances = {};
            const previous = {};
            const visited = new Set();

            stations.forEach(st => {
                distances[st.id] = Infinity;
                previous[st.id] = null;
            });

            distances[startId] = 0;

            while (visited.size < stations.length) {
                let closest = null;
                let minDistance = Infinity;

                for (let id in distances) {
                    if (!visited.has(+id) && distances[id] < minDistance) {
                        closest = +id;
                        minDistance = distances[id];
                    }
                }

                if (closest === null) break;

                visited.add(closest);

                for (const neighbor of graph[closest]) {
                    const tentative = distances[closest] + neighbor.distance;
                    if (tentative < distances[neighbor.id]) {
                        distances[neighbor.id] = tentative;
                        previous[neighbor.id] = closest;
                    }
                }
            }

            return { distances, previous };
        }

        
        function getShortestPath(previous, endId) {
            const path = [];
            let current = endId;

            while (current !== null) {
                path.unshift(current);
                current = previous[current];
            }
            
            return path;
        }

        /
         const departId = 1;
        const arriveeId = 300;

        const result = dijkstra(graph, departId);
        const pathIds = getShortestPath(result.previous, arriveeId);

        
        const latlngs = pathIds.map(id => {
        const st = stations.find(s => s.id === id);
        return [st.latitude, st.longitude];
    });

        console.log("Coordonnées du chemin :", latlngs);
        L.polyline(latlngs, {
            color: "black",
            weight: 5,
            opacity: 1.2,
            dashArray: "5, 10"
        }).addTo(map);


    

        function afficherChemin(cheminIds) {
            const latlngs = cheminIds.map(id => {
                const station = stations.find(s => s.id === id);
                return [station.latitude, station.longitude];
            });

            
            L.polyline(latlngs, {
                color: 'black',
                weight: 6,
                opacity: 1.3,
                dashArray: '10, 10' 
            }).addTo(map);
        }

        

        const { distances, previous } = dijkstra(graph, departId);
        const chemin = getShortestPath(previous, arriveeId);

        if (chemin.length > 1) {
            afficherChemin(chemin);
        } else {
            console.warn("Aucun chemin trouvé entre les deux stations.");
        }


        </script>


        }